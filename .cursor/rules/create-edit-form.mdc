---
description: Create Edit/Create forms with useCrud hook, supports Figma designs and custom components
---

# Create Edit/Create Form Rule

Use this rule when creating form pages for admin modules. Supports both standard forms and custom Figma designs with complex field types.

## Standard Form Pattern

### File Structure
```typescript
// src/Pages/ProtectedPaths/[ModuleName]/[ModuleName]FormPage.tsx
import { useParams } from "react-router";
import AppLayout from "@/components/layout/MainLayout/AppLayout";
import AppTitleWithBackButton from "@/components/Commmon/AppTitleWithBackButton";
import AppPageWrapper from "@/components/Commmon/AppPageWrapper";
import AppForm from "@/components/Commmon/AppForm/AppForm";
import useCrud from "@/hooks/useCrud";
import { useNavigate } from "react-router";
import { 
  [moduleName]DefaultValues,
  [moduleName]Schema, 
  [moduleName]InputArr,
  [moduleName]ChangeDataBeforeMutate 
} from "./[ModuleName]FormHelpers";
import { [MODULE]_PAGE_URL } from "@/navigation/urls";
```

### Standard Form Template
```typescript
const [ModuleName]FormPage = () => {
  const { id } = useParams();
  const navigate = useNavigate();
  const isEdit = !!id;

  const { 
    handleSubmit, 
    formUtils, 
    isMetaLoading, 
    isSubmitting,
    metaData // Get metaData from useCrud to pass to inputArr
  } = useCrud({
    submitEndpoint: isEdit 
      ? `[moduleEndpoints].update/${id}` 
      : "[moduleEndpoints].create",
    metaEndpoint: isEdit 
      ? "[moduleEndpoints].updateMeta(id)" 
      : "[moduleEndpoints].createMeta",
    detailEndpoint: isEdit ? `[moduleEndpoints].detail/${id}` : "",
    defaultValues: [moduleName]DefaultValues,
    schema: [moduleName]Schema,
    changeDataBeforeMutate: [moduleName]ChangeDataBeforeMutate,
    isCreate: !isEdit,
    onSubmitSuccess: (res) => {
      navigate([MODULE]_PAGE_URL);
    },
    onMetaAndDetailFetchSuccess: ({ data, formUtils }) => {
        formUtils.reset(data);
    }
  });

  // Pass metaData to inputArr for dynamic options
  const inputArr = [moduleName]InputArr(formUtils, metaData);

  return (
    <AppLayout>
      <div className="p-6">
        <AppTitleWithBackButton 
          title={isEdit ? "Edit [Module Name]" : "Create [Module Name]"} 
        />
        <AppPageWrapper>
          <AppForm
            inputArr={inputArr}
            onSubmit={handleSubmit}
            formUtils={formUtils}
            isLoading={isMetaLoading}
            isSubmitting={isSubmitting}
          />
        </AppPageWrapper>
      </div>
    </AppLayout>
  );
};

export default [ModuleName]FormPage;
```

## Helper File Pattern

### Module Helper File Structure
```typescript
// src/Pages/ProtectedPaths/[ModuleName]/[ModuleName]FormHelpers.tsx
import type { InputGroup } from "@/components/Commmon/types";
import z from "zod";
import { CustomComponent } from "./components/CustomComponent";

// 1. Default values for forms
export const [moduleName]DefaultValues = {
  field1: "",
  field2: "",
  arrayField: [],
  // ... other fields
};

// 2. Zod validation schema
export const [moduleName]Schema = z.object({
  field1: z.string().min(1, "Field1 is required"),
  field2: z.string().email("Invalid email"),
  arrayField: z.array(z.object({
    name: z.string().min(1),
    value: z.string().min(1),
  })),
  // ... other validations
});

// 3. Form input configuration
// IMPORTANT: Accept metaData as second parameter for dynamic options
export const [moduleName]InputArr = (formUtils: any, metaData?: any): InputGroup[] => [
  {
    // subTitle: "Section Title" - Optional section title
    // outerWrapperClassName: Wraps the entire section including subTitle
    // wrapperClassName: Wraps only the form fields (render array)
    subTitle: "Basic Information",
    outerWrapperClassName: "border border-gray-200 rounded-lg p-6 bg-white shadow-sm",
    wrapperClassName: "grid grid-cols-2 gap-4",
    render: [
      {
        name: "field1",
        type: "text",
        label: "Field 1 Label",
        placeholder: "Enter field 1",
      },
      {
        name: "field2",
        type: "select",
        label: "Field 2 Label",
        placeholder: "Select field 2",
        // Use metaData for dynamic options
        options: metaData?.meta?.field2_options?.map((item: any) => ({
          value: item.id,
          label: item.identity,
        })) || [],
      },
    ],
  },
  {
    subTitle: "Custom Section",
    outerWrapperClassName: "border border-gray-200 rounded-lg p-6 bg-white shadow-sm",
    wrapperClassName: "",
    render: [
      {
        name: "customField",
        type: "custom-comp",
        customComp: <CustomComponent formUtils={formUtils} metaData={metaData} />,
      },
    ],
  },
];

// 4. Data transformation before API call (SUBMIT)
export const [moduleName]ChangeDataBeforeMutate = (body: any) => {
  return {
    ...body,
    // Transform data as needed
    field1: body?.field1?.toLowerCase(),
    meta_data: {
      // Additional metadata
    },
  };
};

// 5. Data transformation before form prefill (EDIT MODE - formUtils.reset)
export const [moduleName]ChangeDataBeforePrefill = (data: any) => {
  // Helper: Array → String
  const arrayToString = (arr: string[] | undefined): string => {
    if (!arr || arr.length === 0) return "";
    return arr.join(", ");
  };

  return {
    // Transform backend data to match form field structure
    field1: data?.field1 || "",
    field2: data?.field2 || "",
    // Array → String (for text inputs)
    arrayField: arrayToString(data?.arrayField),
    // Flatten nested (user_details.field → field)
    nestedField: data?.nested?.field || "",
    // Number → String (for input fields)
    numberField: data?.numberField?.toString() || "",
    // Extract ID from object
    objectField: data?.objectField?.id || "",
  };
};
```

## Custom Component Pattern

### Array Field Component (Following SuggestedMsgComp Pattern)
```typescript
// src/Pages/ProtectedPaths/[ModuleName]/components/ArrayFieldComponent.tsx
import AppInput from "@/components/Commmon/AppForm/AppInput";
import AppText from "@/components/Commmon/AppText";
import { Button } from "@/components/ui/button";
import { Plus, X } from "lucide-react";
import { useFieldArray } from "react-hook-form";

const ArrayFieldComponent = ({ formUtils, fieldName, label, placeholder }: {
  formUtils: any;
  fieldName: string;
  label: string;
  placeholder: string;
}) => {
  const { fields, append, remove } = useFieldArray({
    control: formUtils.control,
    name: fieldName,
  });

  const handleAddItem = () => {
    append({
      name: "",
      value: "",
    });
  };

  const value = formUtils.watch(fieldName);

  return (
    <div className="border-t mt-2 pt-2">
      <div className="flex gap-2 items-center pb-3">
        <AppText
          text={label}
          className="text-text-secondary text-sm font-medium"
        />
      </div>

      <div className="flex flex-col gap-2">
        {fields?.map((field, index) => (
          <div className="flex gap-2 items-center" key={field.id}>
            <div className="flex-1 relative">
              <div className="grid grid-cols-2 gap-2">
                <div className="relative">
                  <AppInput
                    formUtils={formUtils}
                    name={`${fieldName}.${index}.name`}
                    placeholder={`${placeholder} name...`}
                    className="flex-1"
                    maxLength={50}
                  />
                </div>
                <div>
                  <AppInput
                    formUtils={formUtils}
                    name={`${fieldName}.${index}.value`}
                    placeholder={`${placeholder} value...`}
                    className="flex-1"
                    maxLength={50}
                  />
                </div>
              </div>
            </div>

            <Button
              type="button"
              onClick={() => remove(index)}
              variant="outline"
              className="!py-[20px] self-start"
            >
              <X />
            </Button>
          </div>
        ))}
      </div>
      
      <Button
        type="button"
        onClick={handleAddItem}
        variant="outline"
      >
        <Plus /> Add {label}
      </Button>
    </div>
  );
};

export default ArrayFieldComponent;
```

### Custom Component Integration
```typescript
// In helper file
import ArrayFieldComponent from "./components/ArrayFieldComponent";

export const [moduleName]InputArr = (formUtils: any): InputGroup[] => [
  {
    wrapperClassName: "",
    render: [
      {
        name: "arrayField",
        type: "custom-comp",
        customComp: (
          <ArrayFieldComponent
            formUtils={formUtils}
            fieldName="arrayField"
            label="Array Items"
            placeholder="Item"
          />
        ),
      },
    ],
  },
];
```

## Figma Design Integration

### Design Analysis Process
When Figma link or screenshot is provided:

1. **Field Identification** - Extract all input fields, labels, and types
2. **Layout Analysis** - Identify grid layouts, spacing, and grouping
3. **Custom Components** - Identify non-standard fields that need custom components
4. **Validation Rules** - Extract required fields and validation patterns
5. **Conditional Logic** - Identify fields that show/hide based on other values

### Implementation Strategy
```typescript
// Custom form based on Figma design
const CustomFormPage = () => {
  const { handleSubmit, formUtils, isMetaLoading, isSubmitting, isPrefillLoading } = useCrud({
    submitEndpoint: "[moduleEndpoints].cud", // mostly cud endpoint for create and update
    metaEndpoint: "[moduleEndpoints].meta",
    detailEndpoint: "",
    defaultValues: customDefaultValues,
    schema: customSchema,
    changeDataBeforeMutate: customDataTransform,
    isCreate: true,
    onSubmitSuccess: (res) => {
      navigate([MODULE]_PAGE_URL);
    }
  });

  return (
    <AppLayout>
      <div className="p-6">
        <AppTitleWithBackButton title="Custom Form" />
        <AppPageWrapper>
          {/* Custom layout based on Figma */}
          <div className="custom-form-layout">
            <AppForm
              inputArr={customInputArr(formUtils)}
              onSubmit={handleSubmit}
              formUtils={formUtils}
              isLoading={isMetaLoading || isPrefillLoading}
              isSubmitting={isSubmitting}
            />
          </div>
        </AppPageWrapper>
      </div>
    </AppLayout>
  );
};
```

## Schema Requirements

### When Creating Forms, Always Ask For:

#### 1. Meta Endpoint Schema
The meta endpoint provides dynamic options for select fields and initial data for edit mode.

**Standard Meta Response Structure:**
```typescript
// Sample meta endpoint response
{
  "data": {
    "meta": {
      "gender": [
        {
          "id": "male",
          "identity": "Male"
        },
        {
          "id": "female",
          "identity": "Female"
        }
      ],
      "relationship": [
        {
          "id": "mother",
          "identity": "Mother"
        },
        {
          "id": "father",
          "identity": "Father"
        }
      ],
      "date_type": [
        {
          "id": "birthday",
          "identity": "Birthday"
        },
        {
          "id": "anniversary",
          "identity": "Anniversary"
        }
      ]
    },
    "initial": {
      // Initial data for edit mode (only present when id is passed)
      "first_name": "John",
      "last_name": "Doe",
      "email": "john@example.com",
      "gender": "male",
      "family_members": [
        {
          "name": "Jane Doe",
          "relationship": "wife",
          "date_of_birth": "1990-01-01"
        }
      ]
    }
  },
  "status": "success",
  "status_code": 200,
  "action_code": "DO_NOTHING"
}
```

**How to Use Meta Data:**

1. **Dynamic Options**: Extract options from `data.meta` for select fields
```typescript
// In helper file - use meta data for select options
export const [moduleName]InputArr = (formUtils: any, metaData?: any): InputGroup[] => [
  {
    wrapperClassName: "",
    render: [
      {
        name: "gender",
        type: "select",
        label: "Gender",
        placeholder: "Select gender",
        options: metaData?.meta?.gender?.map((item: any) => ({
          value: item.id,
          label: item.identity,
        })) || [],
      },
      {
        name: "relationship",
        type: "select",
        label: "Relationship",
        placeholder: "Select relationship",
        options: metaData?.meta?.relationship?.map((item: any) => ({
          value: item.id,
          label: item.identity,
        })) || [],
      },
    ],
  },
];
```

2. **Initial Data Handling (Form Prefill for Edit Mode)**

**CRITICAL WORKFLOW:**
When implementing edit mode form prefill:
1. **Ask user for the detail or meta API response sample**
2. **Analyze backend data structure vs frontend form structure**
3. **Create `[moduleName]ChangeDataBeforePrefill` function in helper file**
4. **Transform backend data to match React Hook Form (RHF) field structure**
5. **Use transformation in `onMetaAndDetailFetchSuccess` with `formUtils.reset()`**

**Why Transform Before Prefill?**
Backend API response structure often differs from frontend form field structure:

**Implementation Pattern:**

```typescript
// Step 1: In helper file - Create transformation function
export const [moduleName]ChangeDataBeforePrefill = (data: any) => {
  return {
    // Transform backend data to match form field structure
  };
};

// Step 2: In form component - Use transformation with formUtils.reset()
// Option 1: Using initial data from meta endpoint
const { formUtils, handleSubmit, isMetaLoading, isSubmitting } = useCrud({
  submitEndpoint: userEndpoints.create,
  metaEndpoint: isCreate ? userEndpoints.createMeta : userEndpoints.updateMeta(id),
  detailEndpoint: "", // If any
  isCreate: isCreate,
  onMetaAndDetailFetchSuccess: ({ data, formUtils }) => {
    if (data?.initial && !isCreate) {
      // Transform backend data to form structure
      const transformedData = [moduleName]ChangeDataBeforePrefill(data.initial);
      formUtils.reset(transformedData); // Prefill form
    }
  },
  // ... other config
});

// Option 2: Using separate detail endpoint
const { formUtils, handleSubmit, isMetaLoading, isSubmitting } = useCrud({
  submitEndpoint: userEndpoints.create,
  metaEndpoint: userEndpoints.createMeta,
  detailEndpoint: isCreate ? "" : userEndpoints.detail(id),
  isCreate: isCreate,
  onMetaAndDetailFetchSuccess: ({ data, formUtils }) => {
    if (data && !isCreate) {
      // Transform backend data to form structure
      const transformedData = [moduleName]ChangeDataBeforePrefill(data);
      formUtils.reset(transformedData); // Prefill form
    }
  },
  // ... other config
});
```

**Common Meta Patterns:**
```typescript
// Simple array of strings
{
  "statuses": ["active", "inactive", "pending"]
}

// Array of objects with id/identity
{
  "categories": [
    { "id": "cat1", "identity": "Category 1" },
    { "id": "cat2", "identity": "Category 2" }
  ]
}

// Array of objects with id/name
{
  "regions": [
    { "id": 1, "name": "Region 1" },
    { "id": 2, "name": "Region 2" }
  ]
}

// Nested meta data
{
  "permissions": {
    "read": ["view", "list"],
    "write": ["create", "update", "delete"]
  }
}
```

**Real-World Example: User Form with Meta Data**
```typescript
// UserDetailFormPage.tsx
const UserDetailFormPage = () => {
  const { userId } = useParams();
  const navigate = useNavigate();
  const isCreate = userId === "create";
  
  const { formUtils, handleSubmit, isMetaLoading, isSubmitting, metaData } = useCrud({
    submitEndpoint: userEndpoints.create,
    metaEndpoint: isCreate 
      ? userEndpoints.createMeta 
      : userEndpoints.updateMeta(userId || ''),
    detailEndpoint: isCreate ? "" : userEndpoints.detail(userId || ''),
    isCreate: isCreate,
    onMetaAndDetailFetchSuccess: ({ data, formUtils }) => {
      if (data?.initial && !isCreate) {
        formUtils.reset(data.initial);
      }
    },
    defaultValues: usersDefaultValues,
    schema: usersSchema,
    changeDataBeforeMutate: userChangeDataBeforeMutate,
    onSubmitSuccess: () => {
      navigate(USER_PAGE_URL);
    },
  });

  // Pass metaData to inputArr for dynamic select options
  const inputArr = usersInputArr(formUtils, metaData?.data);

  return (
    <AppPageWrapper>
      <AppTitleWithBackButton 
        onBackNavigateTo={USER_PAGE_URL} 
        title={isCreate ? "Create User" : "Edit User"} 
      />
      <AppForm
        inputArr={inputArr}
        onSubmit={handleSubmit}
        formUtils={formUtils}
        isLoading={isMetaLoading}
        isSubmitting={isSubmitting}
      />
    </AppPageWrapper>
  );
};

// UsersFormHelpers.tsx
export const usersInputArr = (formUtils: any, metaData?: any): InputGroup[] => [
  {
    subTitle: "Basic Information",
    outerWrapperClassName: "border border-gray-200 rounded-lg p-6 bg-white shadow-sm",
    wrapperClassName: "grid grid-cols-2 gap-4",
    render: [
      {
        name: "gender",
        type: "select",
        label: "Gender",
        placeholder: "Select gender",
        // Map meta data to select options
        options: metaData?.meta?.gender?.map((item: any) => ({
          value: item.id,
          label: item.identity,
        })) || [],
      },
    ],
  },
  {
    wrapperClassName: "border border-gray-200 rounded-lg p-6 bg-white shadow-sm",
    render: [
      {
        name: "family_members",
        type: "custom-comp",
        // Pass metaData to custom component for relationship options
        customComp: (
          <FamilyMembersComponent 
            formUtils={formUtils} 
            metaData={metaData} 
          />
        ),
      },
    ],
  },
];

// FamilyMembersComponent.tsx
const FamilyMembersComponent = ({ 
  formUtils, 
  metaData 
}: { 
  formUtils: any; 
  metaData?: any; 
}) => {
  const { fields, append, remove } = useFieldArray({
    control: formUtils.control,
    name: "family_members",
  });

  // Extract relationship options from metaData
  const relationshipOptions = metaData?.meta?.relationship?.map((item: any) => ({
    value: item.id,
    label: item.identity,
  })) || [];

  return (
    <div>
      {fields.map((field, index) => (
        <div key={field.id}>
          <AppSelect
            formUtils={formUtils}
            name={`family_members.${index}.relationship`}
            label="Relationship"
            options={relationshipOptions}
          />
        </div>
      ))}
    </div>
  );
};
```

#### 2. Submit Endpoint Schema
**CRITICAL**: When provided, check whether the backend keys match the frontend form keys. If not, change the FE form keys to match the backend keys.

```typescript
// Ask user for expected submit payload
// Example:
{
  "first_name": "string",
  "last_name": "string",
  "email": "string",
  "phone_number": "string",
  "gender": "male|female|others",
  "region": "string",
  "profile_picture": {
    "id": "number",
    "file": "string"
  },
  "family_members": [
    {
      "name": "string",
      "relationship": "mother|father|son|daughter",
      "date_of_birth": "YYYY-MM-DD"
    }
  ],
  "important_dates": [
    {
      "type": "birthday|anniversary",
      "person_name": "string",
      "date": "YYYY-MM-DD"
    }
  ],
  "meta_data": {
    "custom_field": "string"
  }
}
```

### Chrome MCP Integration
When user requests Chrome MCP usage:
1. **Network Tab Analysis** - Capture API requests and responses
2. **Console Log Analysis** - Extract data structures from console.log
3. **Schema Extraction** - Build TypeScript interfaces from captured data
4. **Validation Rules** - Extract validation patterns from API responses

## Advanced Field Types

### Conditional Fields
```typescript
// In helper file
export const [moduleName]InputArr = (formUtils: any): InputGroup[] => {
  const watchField = formUtils.watch("fieldName");
  
  return [
    {
      wrapperClassName: "grid grid-cols-2 gap-4",
      render: [
        {
          name: "field1",
          type: "select",
          label: "Field 1",
          options: [
            { value: "option1", label: "Option 1" },
            { value: "option2", label: "Option 2" },
          ],
        },
        // Conditional field
        ...(watchField === "option1" ? [{
          name: "conditionalField",
          type: "text",
          label: "Conditional Field",
          placeholder: "Enter value",
        }] : []),
      ],
    },
  ];
};
```

### File Upload Fields
```typescript
{
  name: "fileField",
  type: "file",
  label: "Upload File",
  accept: "image/*,.pdf",
  multiple: false,
}
```

### Date/Time Fields
```typescript
{
  name: "dateField",
  type: "date",
  label: "Select Date",
  required: true,
}
```

### Phone Fields
```typescript
{
  name: "phoneField",
  type: "phone",
  label: "Phone Number",
  required: true,
}
```

## CRITICAL MISTAKES TO AVOID

### ❌ NEVER Create Useless Custom Components
**DO NOT create custom-comp types that don't do anything functional.**

```typescript
// ❌ WRONG - Useless custom component
{
  name: "section_header",
  type: "custom-comp",
  customComp: (
    <div>
      <h3>Section Title</h3>
    </div>
  ),
}

// ✅ CORRECT - Use subTitle property
{
  subTitle: "Section Title",
  wrapperClassName: "border rounded-lg p-6",
  render: [/* actual form fields */]
}
```

### ❌ NEVER Place Custom Components Inline
**Always create separate component files for custom functionality.**

```typescript
// ❌ WRONG - Inline custom component
{
  name: "custom_field",
  type: "custom-comp",
  customComp: <div>........</div>,
}

// ✅ CORRECT - Create separate component file
// src/Pages/ProtectedPaths/[ModuleName]/components/CustomFieldComponent.tsx
import CustomFieldComponent from "./components/CustomFieldComponent";

{
  name: "custom_field",
  type: "custom-comp",
  customComp: <CustomFieldComponent formUtils={formUtils} />,
}
```

### ❌ ALWAYS Ask Questions About Complex Functionality
**Before implementing any custom component, ASK the user:**

1. **File Upload**: How should file upload work? What file types? Size limits?
2. **Dynamic Arrays**: How should add/remove work? Any validation?
3. **Conditional Fields**: What triggers show/hide? Any dependencies?
4. **Custom Validation**: Any special validation rules?
5. **API Integration**: How should data be structured for API calls?

### ❌ NEVER Assume Functionality
**If you don't understand how something should work, ASK the user first.**

## Implementation Checklist

### Standard Form:
- [ ] Create form page component
- [ ] Create helper file with all configurations
- [ ] Implement useCrud hook integration
- [ ] Add proper navigation and routing
- [ ] Handle create/edit modes
- [ ] Add loading and error states

### Custom Figma Design:
- [ ] Analyze Figma design/screenshot
- [ ] Extract field types and layout
- [ ] Create custom components if needed
- [ ] Implement conditional logic
- [ ] Match exact styling and spacing
- [ ] Test responsive design

### Schema Integration:
- [ ] Request meta endpoint schema
- [ ] Request submit endpoint schema
- [ ] Use Chrome MCP if requested
- [ ] Build proper TypeScript interfaces
- [ ] Implement data transformation

### Advanced Features:
- [ ] Array field components
- [ ] Conditional field rendering
- [ ] Custom validation rules
- [ ] File upload handling
- [ ] Multi-step form preparation

## Common Patterns

### Form Validation
```typescript
export const [moduleName]Schema = z.object({
  email: z.string().email("Invalid email format"),
  phone: z.string().min(10, "Phone must be at least 10 digits"),
  arrayField: z.array(z.object({
    name: z.string().min(1, "Name is required"),
    value: z.string().min(1, "Value is required"),
  })).min(1, "At least one item required"),
});
```

### Data Transformation
```typescript
export const [moduleName]ChangeDataBeforeMutate = (body: any) => {
  return {
    ...body,
    // Transform arrays
    arrayField: body.arrayField?.filter(item => item.name && item.value),
    // Add metadata
    meta_data: {
      created_at: new Date().toISOString(),
      user_id: getCurrentUserId(),
    },
  };
};
```

This rule ensures consistent, feature-rich form creation that can handle complex designs and requirements while maintaining the established patterns.